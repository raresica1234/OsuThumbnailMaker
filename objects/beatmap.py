from objects.customstring import CustomString
from objects.rankedstatus import RankedStatus
import struct
import math


class Beatmap:
	def __init__(self, file, osu_version):
		self.__file = file
		if osu_version < 20191106:
			file.read(4) # size of beatmap entry
		self.artist_name = str(CustomString(file))
		CustomString(file, True) # artist_name_unicoe
		self.song_title = str(CustomString(file))
		CustomString(file, True) # song title unicode
		self.creator_name = str(CustomString(file))
		self.difficulty_name = str(CustomString(file))
		CustomString(file, True) # audio file
		CustomString(file, True) # hash
		self.file_name = str(CustomString(file))
		self._ranked_status = RankedStatus(self.__parse_byte())
		file.read(2) # circle count
		file.read(2) # slider count
		file.read(2) # spinner count
		file.read(8) # modification time

		if osu_version < 20140609:
			self.approach_rate = float(file.read(1))
			self.circle_size = float(file.read(1))
			self.hp_drain = float(file.read(1))
			self.overall_difficulty = float(file.read(1))
		else:
			self.approach_rate = self.__parse_float()
			self.circle_size = self.__parse_float()
			self.hp_drain = self.__parse_float()
			self.overall_difficulty = self.__parse_float()

		self.slider_velocity = self.__parse_double()
		self.star_rating = {}
		if osu_version >= 20140609:
			count = self.__parse_int()
			# TODO: parse the int double pars
			for j in range(0, count):
				assert(file.read(1) == b'\x08')
				mod_combination = self.__parse_int()
				assert(file.read(1) == b'\x0d')
				star_rating = self.__parse_double()
				self.star_rating[mod_combination] = star_rating

			for i in range(0,3): # skip the next 3 int-double pairs
				count = self.__parse_int()
				for j in range(0, count):
					file.read(14) # size of int-double pair: byte = 0x08, int, byte = 0x0d, double

		file.read(4) # drain time
		file.read(4) # total time
		file.read(4) # audio preview location time

		self.lowest_bpm = math.inf
		self.highest_bpm = -math.inf
		timing_point_count = self.__parse_int()
		for i in range(0, timing_point_count):
			bpm = self.__parse_double()
			bpm = 60 * 1000 / bpm
			file.read(8) # another double for offset and a boolean
			inherited = int(self.__parse_byte())
			if inherited == 1:
				self.lowest_bpm = min(self.lowest_bpm, bpm)
				self.highest_bpm = max(self.highest_bpm, bpm)


		self.beatmap_id = self.__parse_int()
		self.beatmap_set_id = self.__parse_int()

		file.read(4) # thread id
		file.read(4 * 1) # grade for std, taiko, ctb, mania
		file.read(2) # local beatmap offset
		file.read(4) # stack leniency
		file.read(1) # osu gameplay mode
		CustomString(file, True) # song source
		CustomString(file, True) # song tags
		file.read(2) # online offset
		CustomString(file, True) # font used for title of the song
		file.read(1) # beatmap unplayed
		file.read(8) # last time beatmap was played
		file.read(1) # beatmap osz2

		self.folder_name = str(CustomString(file))
		file.read(8) # last time beatmap was checked against osu! repository
		file.read(5 * 1) # ignore beatmap sound, skin, storyboard, video, visual override

		if osu_version < 20140609:
			file.read(2) # skip an unknown short generated by file format inconsistencies

		file.read(4) # last modification time
		file.read(1) # mania scroll speed

	@property
	def ranked_status(self):
		return str(self._ranked_status).split(".")[1]

	def __str__(self):
		return self.artist_name + " - " + self.song_title + " [" + self.difficulty_name + "] " + str(self.ranked_status)

	def __parse_byte(self):
		return int.from_bytes(self.__file.read(1), byteorder='little')

	def __parse_short(self):
		return int.from_bytes(self.__file.read(2), byteorder='little')

	def __parse_int(self):
		return int.from_bytes(self.__file.read(4), byteorder='little')

	def __parse_long(self):
		return int.from_bytes(self.__file.read(8), byteorder='little')

	def __parse_float(self):
		return struct.unpack('f', self.__file.read(4))[0]

	def __parse_double(self):
		return struct.unpack('d', self.__file.read(8))[0]
